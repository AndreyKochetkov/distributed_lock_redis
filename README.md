# distributed_lock_redis

   ## dependences:
        - Redis 
        - Python 3.4 and higher

  ##  Запуск:
        
        рекомендуется использовать virtualenv
        
        $ pip install -r requirements.txt
        
        $ python  app_start.py - просто запустить программу

        $ python  app_start.py [-h] [--getErrors GETERRORS] [--host HOST] [--port PORT]
                    [--db DB] [--cleanTemp CLEANTEMP]
         -h: show help info

         --host: host of redis. Default: "localhost"

         --port: port of redis. Default 6379

         --db: current db of redis. Default: 0

         --getErrors: get error mode. Return all error messages

         --cleanTemp: clean temp messages from db mode

  ##  Описание:  блок схема прилагается

        Генератор отсылает K (10^6) сообщений. Это просто верхняя граница.

        Каждые X (5) сообщений он обновляет блокировку на T (5) секунд.

        Обработчик, обработав N (10) сообщений, пытается захватить блокировку.

        Обработка одного сообщения: взятие из очереди, сохранение во временное хранилище,

        обработка, сохранение в базу, удаление из темпового хранилища.

        Функция sleep(time) имитирует обработку.



 ##   Ограничения и слабые места:
        1. Один обработчик может сделать максимум 10^9 записей, т.к. ограничен размером хеша
        решение:достаточно иногда убивать процесс приложения и перезапускать его
        2. Если приложение упадет в момент когда оно уже получило сообщение из очереди, но не сохранило во временное
        хранилище, то сообщение будет потеряно
            решение:
                2.1 LUA скрипт должен помочь решить эту проблему. Не стал делать это в рамках тестового задания
                2.2 Расширение сущностей, т.е. в реальности приложения работают на разных серверах и можно настроить
                    кэширование на прокси, к примеру.
        3. Персистентность. Я не настраивал slave репликацию и append log в рамках тестового задания. В боевом задаче
            необходимо реализовать не только персистентность посредством репликации и лога, но и балансировку нагрузки




